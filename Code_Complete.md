#Code Complete(代码大全) 读书笔记


	
---

##第一章：欢迎进入软件构建的世界

###软件开发过程

+ 定义问题
+ 需求分析
+ 规划构建
+ 软件架构（高层设计）
+ 详细设计
+ 编码与调试
+ 单元测试
+ 集成测试
+ 集成
+ 系统测试
+ 保障维护

##第二章：用隐喻来更充分地理解软件开发

举了一系列的比喻来描述软件开发。
一个深刻的例子是用建造房屋来隐喻构建活动。

##第三章：三思而后行：前期准备

> 高质量的实践方法在项目的前、中、后期都强调质量

> 方法论应该选用最新最好的，而不是无知地做出选择。当然也应该公平地对待“旧且可靠的方法”

+ 需求分析出问题，会导致浪费大量时间去解决一个错误的问题。
+ 没有好的需求，可能对问题有整体的把握，但却没有击中问题的特定方面。
+ 需求像水，如果冻结了就容易在上面开展建设。

+ 好的架构使锝构建活动变得更容易。糟糕的架构则使构建活动几乎寸步难行。
+ 离开了良好的软件架构，你可能瞄准了正确的问题，但却用了错误的解决方案。也许完全不可能有成功的构建。
+ 架构应该踏在对系统“欠描述”和“过度描述”之间的那条分界线上。

##第四章：关键的“构建”决策

+ 选择编程语言 
+ 编程约定
+ 从“在一种语言上编程（Programming in a language）”转变到“深入一种语言去编程（Programming into a language）”

##第五章：软件构建中的设计

> 有两种设计软件的方式：一种方法是让设计非常简单，看上去明显没有缺陷；另一种方法是让设计非常复杂，看上去没有明显的缺陷。
> 当我解决问题的时候，我从来不考虑美感。我只想着如何才能解决它。但一旦解决了问题，如果解决方法不够优美，我就知道做错了。

####高质量设计的特征：
+ 最小的复杂度
+ 易于维护
+ 松散耦合
+ 可扩展性
+ 可重用性
+ 高扇入
+ 低扇出
+ 可移植性
+ 精简性
+ 层次性
+ 标准技术

> 一个程序中的设计层次。软件系统①首先被组织为子系统②。子系统被进一步分解为类③，然后类又被分解为子程序和数据④。每个子程序的内部也需要进行设计⑤

####软件设计的一些方法

+ 找出现实世界中的对象
+ 形成一致的抽象
+ 封装实现细节
+ 当继承能简化设计时就继承
+ 信息隐藏

##第六章：可以工作的类

####类的基础：抽象数据类型(ADTs)

`ADT(Abstract data type)`是指一些数据以及对这些数据所进行的操作的集合。可以让我们像在现实世界中一样操作实体，而不必在低层的实现上操作实体。

####良好的类接口
+ 好的抽象
	+ 类的接口应该展现一致的抽象层次
	+ 能理解类所实现的抽象
	+ 提供成对的服务
	+ 把不相关的信息转移到其他类中
	+ 尽可能的让接口可编程，而不是表达语义
	+ 谨防在修改时破坏接口的抽象
	+ 不要添加与接口抽象不一致的公用成员
	+ 同时考虑抽象性与内聚性
	
+ 良好的封装
	+ 尽可能的限制类和成员的可访问性
	+ 不要公开暴露成员数据
	+ 不要对类的使用者做出任何假设
	+ 避免使用友元类
	+ 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口
	+ 让阅读代码比编写代码更方便
	+ 要格外警惕从语义上破坏封装性
	+ 留意过于紧密的耦合关系
	
####创建类的原因
+ 为现实世界的对象建模
+ 为抽象的对象建模
+ 降低复杂度
+ 隔离复杂度
+ 隐藏实现细节
+ 限制变动的影响范围
+ 隐藏全局数据
+ 让参数传递更加顺畅
+ 建立中心控制点
+ 让代码更易重用
+ 为程序族做计划
+ 把相关操作包装到一起
+ 实现某种特定的重构

##第七章：高质量的子程序

####子程序是为实现一个特定的目的而编写的一个可被调用的方法或过程

####创建子程序的理由
+ 降低复杂度
+ 引入中间、易懂的抽象
+ 避免代码重复
+ 支持子类化
+ 隐藏顺序
+ 隐藏指针操作
+ 提高可移植性
+ 简化复杂的布尔判断
+ 改善性能
+ 除此以外，创建类的很多理由也是创建子程序的理由

####好的子程序名字
+ 描述子程序所做的事情
+ 避免使用无意义的、模糊或表述不清的动词
+ 不要仅通过数字来形成不同的子程序名字
+ 根据需要确定子程序名字的长度
+ 给函数命名时要对返回值有所描述
+ 给过程命名时使用语气强烈的动词加宾语的形式
+ 准确使用对仗词

	| | | | |
	|:---:|:---:|:---:|:---:|
	|add / remove|increment / decrement|open / close|begin / end|
	|insert / delete|show / hide|create / destroy|lock / unlock|
	|source / target|first / last|start / stop|get / put|
	|next / previous|up / down|get / set|old / new|
	
+ 为常用操作确立命名规则

####如何使用子程序参数
+ 按照 `输入-修改-输出` 的顺序排列参数
+ 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致
+ 使用所有的参数
+ 把状态或出错变量放在最后
+ 不要把子程序的参数用作工作变量
+ 在接口中对参数的假定加以说明
+ 把子程序的参数个数限制在大约7个以内
+ 考虑对参数采用某种表示输入、修改、输出的命名规则
+ 为子程序传递用以维持其接口抽象的变量或对象
+ 确保实际参数与形式参数相匹配

##第八章：防御式编程

####防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般的说，其核心想法是要承认程序都会有问题，都需要被修改。

####保护程序免遭非法输入数据的破坏
+ 检查所有来源于外部的数据的值
+ 检查子程序所有输入参数的值
+ 决定如何处理错误的输入数据

####断言可以用于在代码中说明各种假定，澄清各种不希望的情形
+ 断言主要是用于开发和维护阶段，并不希望用户看到产品代码中的断言信息
+ 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况
+ 避免把需要执行的代码放到断言中
+ 用断言来注解并验证前条件和后条件
+ 对于高健壮性的代码，应该先使用断言再处理错误

####错误处理技术
+ 返回中立值
+ 换用下一个正确的数据
+ 返回与前次相同的数据
+ 换用最接近的合法值
+ 把警告信息记录到日志文件中
+ 返回一个错误码
+ 调用错误处理子程序或对象
+ 当错误发生时显示错误消息
+ 用最妥当的方式在局部处理错误
+ 关闭程序

####异常的使用建议
+ 用异常通知程序的其他部分，发生了不可忽略的错误
+ 旨在真正例外的情况下才抛出异常
+ 不能用异常来推卸责任
+ 避免在构造函数和析构函数中抛出异常
+ 在恰当的抽象层次抛出异常
+ 在异常消息中加入关于导致异常发生的全部信息
+ 避免使用空的catch语句
+ 了解所用函数库可能抛出的异常
+ 考虑创建一个集中的异常报告机制
+ 在项目中对异常的使用标准化
+ 考虑异常的替换方案

####确定在产品代码中该保留多少防御式代码
+ 保留那些检查重要错误的代码
+ 去掉检查细微错误的代码
+ 去掉可以导致程序硬性崩溃的代码
+ 保留可以让程序稳妥地崩溃的代码
+ 为你的技术支持人员记录错误信息
+ 确认留在代码中的错误消息是友好的

##第九章：伪代码编程过程
####创建一个类的步骤
+ 创建类的总体设计
+ 创建类中的子程序
+ 复审并测试整个类

####创建子程序的步骤
+ 设计子程序
+ 检查设计
+ 编写子程序的代码
+ 复审并测试代码

####根据伪代码构建子程序
+ 写作子程序的声明
+ 编写第一条和最后一条语句，将伪代码转换为高层次的注释
+ 每条注释下面填充代码
+ 检查代码
+ 收尾工作

####伪代码编程过程的替代方案
+ 测试先行开发
+ 重构
+ 契约式设计

##第十章：使用变量的一般事项

####变量初始化原则
+ 在声明变量的时候初始化
+ 在靠近变量第一次使用的位置初始化它
+ 理想情况下，在靠近第一次使用变量的位置声明和定义该变量
+ 在可能的情况下使用final或者const
+ 特别注意计数器和累加器
+ 在类的构造函数里初始化该类的数据成员
+ 检查是否需要重新初始化
+ 一次性初始化具名常量：用可执行代码来初始化变量
+ 使用编译器设置来自动初始化所有变量
+ 利用编译器的警告信息
+ 检查输入参数的合法性
+ 使用内存访问检查工具来检查错误的指针
+ 在程序开始时初始化工作内存
